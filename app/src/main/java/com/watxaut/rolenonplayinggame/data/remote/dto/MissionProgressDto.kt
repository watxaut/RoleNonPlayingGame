package com.watxaut.rolenonplayinggame.data.remote.dto

import com.watxaut.rolenonplayinggame.domain.model.LoreCategory
import com.watxaut.rolenonplayinggame.domain.model.LoreDiscovery
import com.watxaut.rolenonplayinggame.domain.model.LoreSourceType
import com.watxaut.rolenonplayinggame.domain.model.PrincipalMissionProgress
import com.watxaut.rolenonplayinggame.domain.model.SecondaryMissionProgress
import com.watxaut.rolenonplayinggame.domain.model.SecondaryMissionStatus
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import java.time.Instant

/**
 * DTO for principal_mission_progress table in Supabase
 */
@Serializable
data class PrincipalMissionProgressDto(
    val id: String? = null, // UUID generated by Supabase
    @SerialName("character_id") val characterId: String,
    @SerialName("mission_id") val missionId: String,
    val status: String = "in_progress", // 'in_progress', 'completed', 'abandoned'
    @SerialName("completed_step_ids") val completedStepIds: List<String> = emptyList(),
    @SerialName("boss_encountered") val bossEncountered: Boolean = false,
    @SerialName("boss_defeated") val bossDefeated: Boolean = false,
    @SerialName("started_at") val startedAt: String? = null, // ISO 8601 timestamp
    @SerialName("completed_at") val completedAt: String? = null,
    @SerialName("last_progress_at") val lastProgressAt: String? = null,
    @SerialName("progress_percentage") val progressPercentage: Int = 0
) {
    /**
     * Convert to domain model
     */
    fun toDomainModel(): PrincipalMissionProgress {
        return PrincipalMissionProgress(
            missionId = missionId,
            completedSteps = completedStepIds.toSet(),
            bossEncountered = bossEncountered,
            bossDefeated = bossDefeated,
            startedAt = startedAt?.let { parseTimestamp(it) } ?: System.currentTimeMillis(),
            completedAt = completedAt?.let { parseTimestamp(it) }
        )
    }

    companion object {
        /**
         * Create DTO from domain model
         */
        fun fromDomainModel(characterId: String, progress: PrincipalMissionProgress): PrincipalMissionProgressDto {
            return PrincipalMissionProgressDto(
                characterId = characterId,
                missionId = progress.missionId,
                status = if (progress.isComplete()) "completed" else "in_progress",
                completedStepIds = progress.completedSteps.toList(),
                bossEncountered = progress.bossEncountered,
                bossDefeated = progress.bossDefeated,
                startedAt = Instant.ofEpochMilli(progress.startedAt).toString(),
                completedAt = progress.completedAt?.let { Instant.ofEpochMilli(it).toString() }
            )
        }

        /**
         * Parse ISO 8601 timestamp to epoch millis
         */
        private fun parseTimestamp(timestamp: String): Long {
            return try {
                Instant.parse(timestamp).toEpochMilli()
            } catch (e: Exception) {
                System.currentTimeMillis()
            }
        }
    }
}

/**
 * DTO for secondary_mission_progress table in Supabase
 */
@Serializable
data class SecondaryMissionProgressDto(
    val id: String? = null, // UUID generated by Supabase
    @SerialName("character_id") val characterId: String,
    @SerialName("mission_id") val missionId: String,
    val status: String = "ongoing", // 'ongoing', 'completed'
    @SerialName("current_progress") val currentProgress: String? = null,
    @SerialName("discovered_at") val discoveredAt: String? = null,
    @SerialName("completed_at") val completedAt: String? = null,
    @SerialName("reward_experience") val rewardExperience: Long? = null,
    @SerialName("reward_gold") val rewardGold: Int? = null,
    @SerialName("reward_equipment") val rewardEquipment: String? = null
) {
    /**
     * Convert to domain model
     */
    fun toDomainModel(): SecondaryMissionProgress {
        return SecondaryMissionProgress(
            missionId = missionId,
            status = if (status == "completed") SecondaryMissionStatus.COMPLETED else SecondaryMissionStatus.ONGOING,
            startedAt = discoveredAt?.let { parseTimestamp(it) } ?: System.currentTimeMillis(),
            completedAt = completedAt?.let { parseTimestamp(it) },
            currentProgress = currentProgress ?: ""
        )
    }

    companion object {
        /**
         * Create DTO from domain model
         */
        fun fromDomainModel(characterId: String, progress: SecondaryMissionProgress): SecondaryMissionProgressDto {
            return SecondaryMissionProgressDto(
                characterId = characterId,
                missionId = progress.missionId,
                status = if (progress.isComplete()) "completed" else "ongoing",
                currentProgress = progress.currentProgress,
                discoveredAt = Instant.ofEpochMilli(progress.startedAt).toString(),
                completedAt = progress.completedAt?.let { Instant.ofEpochMilli(it).toString() }
            )
        }

        /**
         * Parse ISO 8601 timestamp to epoch millis
         */
        private fun parseTimestamp(timestamp: String): Long {
            return try {
                Instant.parse(timestamp).toEpochMilli()
            } catch (e: Exception) {
                System.currentTimeMillis()
            }
        }
    }
}

/**
 * DTO for lore_discoveries table in Supabase
 */
@Serializable
data class LoreDiscoveryDto(
    val id: String? = null, // UUID generated by Supabase
    @SerialName("character_id") val characterId: String,
    @SerialName("lore_category") val loreCategory: String,
    @SerialName("lore_title") val loreTitle: String,
    @SerialName("lore_content") val loreContent: String,
    @SerialName("source_type") val sourceType: String,
    @SerialName("source_id") val sourceId: String? = null,
    @SerialName("discovered_at") val discoveredAt: String? = null
) {
    /**
     * Convert to domain model
     */
    fun toDomainModel(): LoreDiscovery {
        return LoreDiscovery(
            id = id ?: "",
            category = parseLoreCategory(loreCategory),
            title = loreTitle,
            content = loreContent,
            discoveredAt = discoveredAt?.let { parseTimestamp(it) } ?: System.currentTimeMillis(),
            sourceType = parseLoreSourceType(sourceType),
            sourceId = sourceId ?: ""
        )
    }

    companion object {
        /**
         * Create DTO from domain model
         */
        fun fromDomainModel(characterId: String, discovery: LoreDiscovery): LoreDiscoveryDto {
            return LoreDiscoveryDto(
                id = discovery.id.takeIf { it.isNotEmpty() },
                characterId = characterId,
                loreCategory = discovery.category.name,
                loreTitle = discovery.title,
                loreContent = discovery.content,
                sourceType = discovery.sourceType.name,
                sourceId = discovery.sourceId.takeIf { it.isNotEmpty() },
                discoveredAt = Instant.ofEpochMilli(discovery.discoveredAt).toString()
            )
        }

        /**
         * Parse lore category from string
         */
        private fun parseLoreCategory(category: String): LoreCategory {
            return try {
                LoreCategory.valueOf(category)
            } catch (e: Exception) {
                LoreCategory.WORLD_HISTORY
            }
        }

        /**
         * Parse lore source type from string
         */
        private fun parseLoreSourceType(sourceType: String): LoreSourceType {
            return try {
                LoreSourceType.valueOf(sourceType)
            } catch (e: Exception) {
                LoreSourceType.LOCATION_DISCOVERY
            }
        }

        /**
         * Parse ISO 8601 timestamp to epoch millis
         */
        private fun parseTimestamp(timestamp: String): Long {
            return try {
                Instant.parse(timestamp).toEpochMilli()
            } catch (e: Exception) {
                System.currentTimeMillis()
            }
        }
    }
}
